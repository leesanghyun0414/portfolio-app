# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
	query: Query
	mutation: Mutation
}

"An object with an ID"
interface Node {
	"The ID of the object."
	id: ID!
}

type AuthorType {
	bio: String!
	id: ID!
	like: [LikeType!]!
	postSet: [PostType!]!
	user: UserType!
	website: String!
}

type CreatePost {
	body: String
	post: PostType
}

type LikePost {
	isLiked: Boolean
	postId: ID
	userId: ID
}

type LikeType {
	dateCreated: DateTime!
	dateModified: DateTime!
	id: ID!
	post: PostType!
	user: AuthorType!
}

type Mutation {
	createPost(subtitle: String, text: String, title: String, username: String): CreatePost
	likePost(postId: ID, userId: ID): LikePost
	"""

	Register user with fields defined in the settings.

	If the email field of the user model is part of the
	registration fields (default), check if there is
	no user with that email or as a secondary email.

	If it exists, it does not register the user,
	even if the email field is not defined as unique
	(default of the default django user model).

	When creating the user, it also creates a `UserStatus`
	related to that user, making it possible to track
	if the user is archived, verified and has a secondary
	email.

	Send account verification email.

	If allowed to not verified users login, return token.
	"""
	register(email: String!, password1: String!, password2: String!, username: String!): Register
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
	"When paginating forwards, the cursor to continue."
	endCursor: String
	"When paginating forwards, are there more items?"
	hasNextPage: Boolean!
	"When paginating backwards, are there more items?"
	hasPreviousPage: Boolean!
	"When paginating backwards, the cursor to continue."
	startCursor: String
}

type PostBodyType {
	dateCreated: DateTime!
	dateModified: DateTime!
	id: ID!
	post: PostType!
	text: String!
}

type PostType {
	author: AuthorType!
	body: PostBodyType
	dateCreated: DateTime!
	dateModified: DateTime!
	id: ID!
	like: [LikeType!]!
	photo: String!
	publishDate: DateTime
	published: Boolean!
	subtitle: String!
	tag(after: String, before: String, first: Int, last: Int, name: String, name_Icontains: String, offset: Int): TagNodeConnection!
	title: String!
}

type Query {
	allLikedPostByUser(userId: ID!): [PostType]
	allPosts: [PostType]
	allTags(after: String, before: String, first: Int, last: Int, name: String, name_Icontains: String, offset: Int): TagNodeConnection
	authorByUser(username: String): AuthorType
	me: UserNode
	postBody(postId: ID!): PostBodyType
	postByAuthor(username: String): [PostType]
	postById(postId: ID!): PostType
	postByTag(tag: String): [PostType]
	tag(
		"The ID of the object"
		id: ID!
	): TagNode
	totalLikeCountByPost(postId: Int!): Int
	totalLikeCountByUser(postId: Int!): Int
	user(
		"The ID of the object"
		id: ID!
	): UserNode
	users(after: String, before: String, email: String, first: Int, isActive: Boolean, last: Int, offset: Int, status_Archived: Boolean, status_SecondaryEmail: String, status_Verified: Boolean, username: String, username_Icontains: String, username_Istartswith: String): UserNodeConnection
}

"""

Register user with fields defined in the settings.

If the email field of the user model is part of the
registration fields (default), check if there is
no user with that email or as a secondary email.

If it exists, it does not register the user,
even if the email field is not defined as unique
(default of the default django user model).

When creating the user, it also creates a `UserStatus`
related to that user, making it possible to track
if the user is archived, verified and has a secondary
email.

Send account verification email.

If allowed to not verified users login, return token.
"""
type Register {
	errors: ExpectedErrorType
	refreshToken: String
	success: Boolean
	token: String
}

type TagNode implements Node {
	"The ID of the object."
	id: ID!
	name: String!
	postSet: [PostType!]!
}

type TagNodeConnection {
	"Contains the nodes in this connection."
	edges: [TagNodeEdge]!
	"Pagination data for this connection."
	pageInfo: PageInfo!
}

"A Relay edge containing a `TagNode` and its cursor."
type TagNodeEdge {
	"A cursor for use in pagination"
	cursor: String!
	"The item at the end of the edge"
	node: TagNode
}

type UserNode implements Node {
	archived: Boolean
	dateJoined: DateTime!
	email: String!
	firstName: String!
	"The ID of the object."
	id: ID!
	"ユーザーがアクティブかどうかを示します。アカウントを削除する代わりに選択を解除してください。"
	isActive: Boolean!
	"ユーザーが管理サイトにログイン可能かどうかを示します。"
	isStaff: Boolean!
	lastLogin: DateTime
	lastName: String!
	pk: Int
	profile: AuthorType
	secondaryEmail: String
	"この項目は必須です。半角アルファベット、半角数字、@/./+/-/_ で150文字以下にしてください。"
	username: String!
	verified: Boolean
}

type UserNodeConnection {
	"Contains the nodes in this connection."
	edges: [UserNodeEdge]!
	"Pagination data for this connection."
	pageInfo: PageInfo!
}

"A Relay edge containing a `UserNode` and its cursor."
type UserNodeEdge {
	"A cursor for use in pagination"
	cursor: String!
	"The item at the end of the edge"
	node: UserNode
}

type UserType {
	dateJoined: DateTime!
	email: String!
	firstName: String!
	id: ID!
	"ユーザーがアクティブかどうかを示します。アカウントを削除する代わりに選択を解除してください。"
	isActive: Boolean!
	"ユーザーが管理サイトにログイン可能かどうかを示します。"
	isStaff: Boolean!
	"全ての権限を持っているとみなされます。"
	isSuperuser: Boolean!
	lastLogin: DateTime
	lastName: String!
	password: String!
	profile: AuthorType
	"この項目は必須です。半角アルファベット、半角数字、@/./+/-/_ で150文字以下にしてください。"
	username: String!
}


"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
Errors messages and codes mapped to
fields or non fields errors.
Example:
{
field_name: [
{
"message": "error message",
"code": "error_code"
}
],
other_field: [
{
"message": "error message",
"code": "error_code"
}
],
nonFieldErrors: [
{
"message": "error message",
"code": "error_code"
}
]
}
"""
scalar ExpectedErrorType
